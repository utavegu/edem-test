## Инструкция по запуску проекта

Для запуска проекта в системе должны быть установлены Docker и docker-compose. Разработка приложения велась на Docker версии 24.0.7 и docker-compose версии 2.12.2

Сначала в корне проекта нужно создать файл .env и скопировать туда содержимое .env-example, заменив значения на нужные. Далее открыть терминал, находясь в корневой директории проекта, и ввести туда команду:

```bash
docker-compose -f docker-compose.preprod.yml up
```

После того как все контейнеры успешно запустятся, клиентская часть будет развёрнута на 3000 порту (http://localhost:3000). Зайдите туда и убедитесь, что всё работает.

Однако, в данный момент в базе данных ещё пусто и чтобы сделать миграцию из моковой базы данных в настоящую, единожды введите в терминале команду (требует наличие curl):
```bash
curl -X POST http://localhost:4000/api/trips/migration
```

Либо, если curl отсутствует, в Postman (или аналогах) выполните POST-запрос на http://localhost:4000/api/trips/migration. Также единожды.

Контейнер с сервером при этом должен быть запущен!

Теперь товары должны были появиться в базе данных и приложение должно работать в соответствие с поставленным ТЗ.


## Информация по зависимостям

node - 20.9.0

npm - 10.1.0

### Client:

Webpack - 5.88.2

React - 18.2.0

TypeScript - 5.2.2

### Server:

Nest - 10.2.1

TypeScript - 5.1.3


## Инструкция к API:

GET http://localhost:4000/api/trips?limit=n&offset=n - запросить все поездки с учётом квери-параметров

GET http://localhost:4000/api/trips/amount - запросить общее количество поездок в базе

POST http://localhost:4000/api/trips/migration - копировать моковую базу данных в реальную (достаточно выполнить только 1 раз)


## Комментарий к выполненному заданию:

В оговоренный срок, в рамках ТЗ, маленько не успел дожать следующее (в основном всё касается сборки Вебпака):
- не подружил его с dotenv;
- можно было бы накрутить побольше оптимизаций на подобии автопрефиксера, различных ужималок кода и картинок, переделывалку растровых изображений в вебпи, обфускатор...;
- алиасы путей;
- хот релоад;
- уменьшение и прочие оптимизации продакш бандла
- научить компоненты читать классы из global.scss
- научить scss-модули понимать переменные и миксины без импорта

Зато накрутил много чего ещё - анализаторы кода, удобную и хорошо масштабируемую структуру, собственный бэкэнд, минимальное аццесибилити.

Использование Redux Toolkit Query обосновываю тем, что это более современный подход. Плюс он очень многое умеет "из коробки" - обработку ошибок, загрузки, асинхронные запросы без обёрток, встроенные длинные запросы и само главное - кэшировать запросы, что сильно снимает нагрузку на сервер и ускоряет работу клиента.

Если бы делал в связке с axios и thunk, тогда бы весь движ по запросу данных происходил в сторе, куда бы я импортировал ручки апи, там же работал бы с асинхронщиной и перехватывал ошибки, а в компоненты отдавал бы только селекторы и диспетчеры.